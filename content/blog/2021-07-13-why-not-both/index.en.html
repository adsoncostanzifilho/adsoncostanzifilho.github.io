---
title: Why not both?
author: Adson Costanzi Filho
date: '2021-07-13'
slug: []
categories:
  - R
  - Tutorial
  - Python
tags:
  - plumber
  - FastAPI
banner: "img/banners/plumber_fast_tutorial.png"
---

<script src="{{< blogdown/postref >}}index.en_files/header-attrs/header-attrs.js"></script>


<div id="motivation" class="section level2">
<h2>Motivation</h2>
<p>I believe the most common discussion on data science teams is R vs Python. I saw myself in some of these discussions a couple of times and my position is always “<em>Why not use both?</em>”. The idea of this post is not to compare R vs Python but to show how easy it is to <strong>integrate both languages using APIs</strong> (LIKE A PRO), this way we can use the best of each. Also, the post won’t focus on the deployment and structure needed to bring the APIs online, instead, I will demonstrate it locally (to make it simple).</p>
<p>This post is divided into 3 sections: <strong>Creating a function</strong>, <strong>Creating an API</strong>, and <strong>Calling an API</strong>. In the first section, you will find a simple function created in R and Python, the second section is about how to transform that functions into APIs, the last one is how we can call/use the APIs.</p>
</div>
<div id="creating-a-function" class="section level2">
<h2>Creating a function</h2>
<p>Imagine that you are working in a data science team and someone needs a piece of code that return the sum of two values (sorry for the stupid example). See, the request is not about R, Python, Julia, Java, or whatever, but to <strong>solve the problem</strong>! So, let’s solve the problem the best way we can, and let’s write a function to solve it in R and Python.</p>
<blockquote>
<p>This post will not cover the guidelines to create useful functions. For that I recommend you to take a look at the <em>Functions section</em> of the <a href="https://adv-r.hadley.nz/functions.html">Advanced R Book</a>.</p>
</blockquote>
<div id="function-in-r" class="section level3">
<h3>Function in R</h3>
<p>A simple function to return the sum of two values in R would look like this:</p>
<pre class="r"><code>sum_two_r &lt;- function(x, y)
{
  result &lt;- x + y
  return(result)
}</code></pre>
<p>It is done, now we can call it <strong>inside R</strong> like this:</p>
<pre class="r"><code>sum_two_r(x = 1, y = 1)</code></pre>
<pre><code>## [1] 2</code></pre>
</div>
<div id="function-in-python" class="section level3">
<h3>Function in Python</h3>
<p>A simple function to return the sum of two values in Python would look like this:</p>
<pre class="python"><code>def sum_two_python(x, y):
  result = x + y
  return result</code></pre>
<p>It is done, now we can call it <strong>inside Python</strong> like this:</p>
<pre class="python"><code>sum_two_python(x = 1, y = 1)</code></pre>
<pre><code>## 2</code></pre>
</div>
</div>
<div id="creating-an-api" class="section level2">
<h2>Creating an API</h2>
<p>The problem is almost solved, but we still need to find the best way to <strong>share our solution with the rest of the team</strong>. Well, the part of the team that works in R can use the function we wrote in R, but that function is simply not available to the part of the team that uses Python, the same happens with the code written in Python which is simply not available to anyone using R. So, it is necessary to create a solution independent of the language to make it reachable for everyone on the team.</p>
<blockquote>
<p>I know the <a href="https://rstudio.github.io/reticulate/">reticulate</a> package can help, but it’s a one-way solution, and we are interested in a more generic form of integration that can be extended not just to Python, but to any programming language.</p>
</blockquote>
<p>One good solution would be to <strong>create and deploy an API</strong> with our piece of code, this way the rest of the team can interact with it independently, in other words, doesn’t matter anymore what was the language you used to solve the problem. To do that we are going to use the <a href="https://www.rplumber.io/">plumber</a> package for R and the <a href="https://fastapi.tiangolo.com/">FastAPI</a> package for Python.</p>
<blockquote>
<p>This post will not cover how to deploy the APIs. However, if you are interested in learning how to bring your APIs online you can use this <a href="https://www.rplumber.io/articles/hosting.html">link</a> for <strong>plumber</strong>, and this <a href="https://fastapi.tiangolo.com/deployment/">link</a> for <strong>FastAPI</strong>.</p>
</blockquote>
<div id="api-in-r" class="section level3">
<h3>API in R</h3>
<p>The first step to create an API in R is to install the <code>plumber</code> package:</p>
<pre class="r"><code>install.packages(&quot;plumber&quot;)</code></pre>
<p>That done, let’s get back to our function file and add a couple of things to it.</p>
<pre class="r"><code>#* @param x first number 
#* @param y second number
#* @get /sum_r

sum_two_r &lt;- function(x, y)
{
  result &lt;- as.numeric(x) + as.numeric(y)
  return(result)
}</code></pre>
<p>Notice that we add some “comments” at the begging of the code very similar to the ones used in the <code>roxygen2</code> package. These comments are the key that plumber uses to transform your functions in APIs endpoints. Also, for this example, we defined a <em>GET</em> request, the same could be done, for example, with <em>POST</em> requests by changing the comment to <code>#* @post /sum_r</code>.</p>
<blockquote>
<p>If you are not familiar with HTTP requests you can take a look at this <a href="https://www.rplumber.io/articles/routing-and-input.html">link</a>.</p>
</blockquote>
<blockquote>
<p>You can see that it was included the <code>as.numeric()</code> transformation, which is necessary because the parameters “enter” R as strings, and to apply mathematical operations it is necessary to transform the numeric ones into numbers.</p>
</blockquote>
<p>The next step is to deploy it! To bring it online you just need to provide the <strong>file path</strong> and the <strong>port</strong> you want to expose the API. We are going to make it available locally (localhost) at the port 8000 by running:</p>
<pre class="r"><code>library(magrittr)
library(plumber)

pr(&#39;functions/sum_r.R&#39;) %&gt;%
  pr_run(port = 8000)</code></pre>
<p>Done! Now our API is exposed and you can access the Swagger documentation at <a href="http://localhost:8000/__docs__/" class="uri">http://localhost:8000/__docs__/</a>, and you can interact with it by pressing <strong>GET</strong>, followed by the <strong>Try it out</strong> button, <strong>fill in the parameters</strong> and press <strong>Execute</strong>.</p>
<p><img src="/img/plumber_fast_tutorial/swagger_plumber.gif" style="width:100.0%" /></p>
<blockquote>
<p>If you want to learn more about <em>Swagger UI</em> here is the <a href="https://swagger.io/">link</a> for you.</p>
</blockquote>
</div>
<div id="api-in-python" class="section level3">
<h3>API in Python</h3>
<p>The first step to create an API in Python is to install the <code>FastAPI</code> package. On the terminal run:</p>
<pre class="bash"><code>$ pip install fastapi[all]
</code></pre>
<p>That done, let’s get back to our function file and add a couple of things to it.</p>
<pre class="python"><code>from fastapi import FastAPI

app = FastAPI()

@app.get(&quot;/sum_py&quot;)
def sum_two_python(x:float, y:float):
  result = x + y
  return result</code></pre>
<p>Notice that we import the fastapi package and we created an object called app that is a FastAPI instance. Then we defined it as a <em>GET</em> request, the same could be done, for example, with <em>POST</em> requests by changing to <code>@app.post("/sum_py")</code>.</p>
<blockquote>
<p>You can see that it was included the <code>:float</code> to force the variable type to be numeric, that is necessary because the default APIs calls “enter” Python as strings, and to apply mathematical operations it is necessary to transform the numeric ones into numbers.</p>
</blockquote>
<p>The next step is to deploy it! To bring it online you just need to open the terminal and get <strong>inside the folder you saved your Python API script</strong>. I named my file as <em>“sum_py”</em> and I am going to make it available locally (localhost) at the port 8080 by running:</p>
<pre class="bash"><code>$ uvicorn sum_py:app --port 8080 --reload
</code></pre>
<blockquote>
<p>The <em>reload</em> option will reload your API every time you save the file. It is a very good feature for development!</p>
</blockquote>
<p>Done! Now our API is exposed and you can access the Swagger documentation at <a href="http://localhost:8080/docs#/" class="uri">http://localhost:8080/docs#/</a>, and you can interact with it by pressing <strong>GET</strong>, followed by the <strong>Try it out</strong> button, <strong>fill in the parameters</strong> and press <strong>Execute</strong>.</p>
<p><img src="/img/plumber_fast_tutorial/swagger_fastapi.gif" style="width:100.0%" /></p>
<p>Of course, in the real world, the deployment of your APIs shouldn’t be local, but the logic will be (almost) the same. Also, there are <strong>MUCH MORE FEATURES</strong> on the API development, so my advice would be to read the <a href="https://www.rplumber.io/">plumber</a> and <a href="https://fastapi.tiangolo.com/">FastAPI</a> documentation to learn more about it.</p>
</div>
</div>
<div id="calling-an-api" class="section level2">
<h2>Calling an API</h2>
<p>From now on, the solution should be available for <strong>EVERYONE</strong> in the team, whether they use Python, R, etc. Now things will get crazy because we are going to call the Python API in R and the R API in Python!!! :dizzy_face:</p>
<p><strong>PS</strong>: Keep both APIs running locally!</p>
<div id="calling-an-api-in-r" class="section level3">
<h3>Calling an API in R</h3>
<p>It is very simple to call APIs using R, and for that, we are going to use the <code>httr</code> package. Let’s install it:</p>
<pre class="r"><code>install.packages(&quot;httr&quot;)</code></pre>
<p>Do you remember that our Python API is running locally (localhost) at the port 8080? Well, that and the request type (<em>GET</em>, in this case) are the only information we need to call it through R.</p>
<pre class="r"><code>library(httr)

python_request &lt;- GET(&#39;http://localhost:8080/sum_py?x=1&amp;y=1&#39;)

python_result &lt;- content(python_request)

python_result</code></pre>
<pre><code>## [1] 2</code></pre>
</div>
<div id="calling-an-api-in-python" class="section level3">
<h3>Calling an API in Python</h3>
<p>Let’s do the same, but this time we are going to call the R API through Python! For that, it will be necessary to install the <code>requests</code> package.</p>
<pre class="bash"><code>$ pip install requests
</code></pre>
<p>Our R API is also running on localhost but at the port 8000. Again, that and the request type (<em>GET</em>, in this case) are the only information we need to call it through Python.</p>
<pre class="python"><code>import requests

r_request = requests.get(&quot;http://localhost:8000/sum_r?x=1&amp;y=1&quot;)

print(r_request.json())</code></pre>
<pre><code>## [2]</code></pre>
</div>
</div>
<div id="that-is-all" class="section level2">
<h2>That is all</h2>
<p>There are <strong>MUCH MORE</strong> to discuss when we talk about APIs/deploy/calls/requests, but the idea was to make it simple, to demonstrate the possibilities, and to <strong>STOP THE FIGHT</strong> between R and Python :laughing:. I believe this post is a good example of how to integrate both languages (LIKE A PRO), because, in the end, we want to <strong>SOLVE THE PROBLEM</strong>!!! Does it really matter if you solved it in Python or R?</p>
<p>I hope someone finds this useful. As always your feedback is much appreciated, feel free to get in touch with me over social media! :smile:</p>
</div>
